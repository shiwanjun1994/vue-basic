# 基础用法
```html
你可以用 v-model 指令在表单 <input>、<textarea> 及 <select> 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 v-model 本质上不过是语法糖。它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。

注意：v-model 会忽略所有表单元素的 value、checked、selected 特性的初始值而总是将 Vue 实例的数据作为数据来源。你应该通过 JavaScript 在组件的 data 选项中声明初始值。
```
v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件：
* text 和 textarea 元素使用 value 属性和 input 事件；
* checkbox 和 radio 使用 checked 属性和 change 事件；
* select 字段将 value 作为 prop 并将 change 作为事件。
  
注意：在文本区域插值 (<textarea>{{text}}</textarea>) 并不会生效，应用 v-model 来代替。

# 修饰符
在默认情况下，v-model 在每次 input 事件触发后将输入框的值与数据进行同步 
```html
<!-- 在“change”时而非“input”时更新-->
<input v-model.lazy="msg" >
不加.lazy这个修饰符的时候 在文本框输入内容的时候就会自动更新视图中的数据
而加了.lazy这个修饰符 文本框输入内容的时候不会自动更新 而只有在change事件触发的时候才会更新视图中的数据

如果想自动将用户的输入值转为数值类型，可以给 v-model 添加 number 修饰符：
如果要自动过滤用户输入的首尾空白字符，可以给 v-model 添加 trim 修饰符：
```

# 在组件上也可以使用v-model
HTML 原生的输入元素类型并不总能满足需求。幸好，Vue 的组件系统允许你创建具有完全自定义行为且可复用的输入组件。这些输入组件甚至可以和 v-model 一起使用！

# 组件化

## 什么是组件化
将页面中的功能进行拆分，每一个功能单独存储成为一个组件，这个过程就是所谓的组件化！组件中包含html,css,javascript代码！

## 组件化和模块化的联系与区别
组件化和模块化都是用来实现代码复用的！组件所包含的内容要比模块大一些，组件中可能会引用到模块！

## 组件化的意义
vue中一般的开发模式都是组件化！
1. 便于功能复用
2. 便于人员分工
3. 代码结构更加清晰，便于维护！

## 注册组件的方式
* 全局注册  
  注意名字 写的时候是什么名字 引用的时候就写什么名字
```js
Vue.component('组件名',{
    data() {
        return {'数据'}
    }
    template: '模板'
})
```
* 局部注册
  注意名字现在是驼峰命名法
```js
components: {
    myheader: {
        template: "<div>登录组件</div>"
    }
}
```

### 注意点：
* data选项 必须是一个函数 
* 因为组件可以有很多个实例，如果data是一个对象，则每个实例用到的都是同一个对象，那么在一个实例中对数据进行修改，会导致其他所有实例中的数据都发生变化。
* 所以我们需要将data写成一个函数，在组件实例被创建的时候，会执行一次data函数，data函数中会返回一个新的唯一的对象，那么每个组件实例都会拥有自己的data实例了，所以互不干扰了！
* 因此每个实例可以维护一份被返回对象的独立的拷贝
如果vue没有这条规则 点击一个按钮就可能会像如下代码一样影响到其它所有的实例
```js
  data () {
      return {
          count: 0
      }
  }
```

## 组件的组织
通常一个应用会以一棵嵌套的组件树的形式来组织：每个组件内有包含了其它引用到的组件
而为了能在模板中使用 这些组件必须先注册以便能够让vue识别 这里注册组件有两种类型：全局注册以及局部注册

全局注册：全局注册的组件可以用在其被注册之后的任何 (通过 new Vue) 新创建的 Vue 根实例，也包括其组件树中的所有子组件的模板中。
局部注册：

# 父组件向子组件传值 prop [属性]

## 通过 Prop 向子组件传递数据
组件上注册的自定义特性 ===> 传递给一个 prop 特性的时候 它就变成了那个组件实例的一个属性 
组件实例的作用域是相互独立的 子组件内的模板无法直接引用父组件内的数据 子组件想要使用父组件的数据 <=== 父组件 需要通过子组件的 props 选项

### 静态props
* 静态Prop通过为子组件在父组件中的占位符添加特性的方式来达到传值的目的 
* 对于props声明的属性来说，在父级HTML模板中，属性名需要使用中划线写法
* 子级props属性声明时，使用小驼峰或者中划线写法都可以；而子级模板使用从父级传来的变量时，需要使用对应的小驼峰写法

### 动态props
在模板中，要动态地绑定父组件的数据到子模板的 props，与绑定到任何普通的HTML特性相类似，就是用 v-bind。每当父组件的数据变化时，该变化也会传导给子组件 让它的值被当作JS表达式计算 

### 验证props 如果使用的是开发版本
可以为组件的 props 指定验证规格。如果传入的数据不符合规格，Vue会发出警告。当组件给其他人使用时，这很有用 要指定验证规格，需要用对象的形式，而不能用字符串数组 当 prop 验证失败，Vue 会在抛出警告 (如果使用的是开发版本)。props会在组件实例创建之前进行校验，所以在 default 或 validator 函数里，诸如 data、computed 或 methods 等实例属性还无法使用

### 修改props(指的是子修改父)
一般情况子组件拿到 父亲传的 props 值直接显示数据，也有少数需在 子组件修改参数。
子组件中修改prop中的数据，通常有以下两种原因
1、prop 作为初始值传入后，子组件想把它当作局部数据来用
2、prop 作为初始值传入，由子组件处理成其它数据输出

一个组件默认可以拥有任意数量的 prop，任何值都可以传递给任何 prop
注意事项：
* 父组件给子组件传参 
* 数据从父组件传递给子组件 只能单向绑定
* 在子组件内不应该修改父组件传递过来的数据（如有特殊情况需要改变）
  
## 父组件、子组件概念
组件（父）中引入另一个组件（子）

## 单个根元素
当构建一个 <blog-post> 组件时，你的模板最终会包含的东西远不止一个标题：还需要发布日期、评论等。为每个相关的信息定义一个prop就会变得很麻烦：让它接收一个post属性 其值是一个对象

## 监听子组件的事件
当我们开发一个需要在多处引用到的重复组件的时候 它的一些功能可能要求我们和父级组件进行沟通 当子组件内部触发了一个事件后 外部（也就是调用子组件的父级组件）应该能相应的感知到事件的触发，从而再出发一些列的操作。

例如：子组件为一个按钮，当按钮被点击时，父级组件会感知，并触发想要触发的操作。v-on 操作可以用来监听某些预设好的事件 比如input、change、click事件 同时也支持访问自定义的事件 所以，当我们调用已注册的组件，如<blog-post>组件，我们可以用v-on为组件预先绑定一个自定义的事件监听器，只要这个自定义事件被触发了，父级组件就会感知到，触发一个操作。具体的预先设置如下：

尽管在子组件里面写了这个按钮 但这个按钮并不会做任何事：
```js
    <button>
        Enlarge text
    </button>
```
当点击按钮的时候 需要告诉父级组件放大所有博文的文本。幸好 Vue 实例提供了一个自定义事件的系统来解决这个问题。父级组件可以像处理 native DOM 事件一样通过 v-on 监听子组件实例的任意事件：
```js
<blog-post
  v-on:enlarge-text="postFontSize += 0.1"
></blog-post>
```
同时子组件可以通过调用内建的 $emit 方法 并传入事件名称来触发一个事件：
```js
    <button v-on:click="$emit('enlarge-text')">
        Enlarge text
    </button>
```
有了这个 v-on:enlarge-text="postFontSize += 0.1" 监听器，父级组件就会接收该事件并更新 postFontSize 的值。

## 使用事件添加一个参数
```js
    <button v-on:click="$emit('enlarge-text', 0.1)">
        Enlarge text
    </button>
```
触发的时候 在父组件给子组件传入一个事件 并添加这个参数
### 注意  $emit传入的事件名称只能使用小写，不能使用大写的驼峰规则命名 模板和触发的方法名都要改成小写！！！

### 具体的实现思路 父组件传参 子组件拿值
1.设定埋伏 准备捕捉子组件的操作 父组件在子组件上添加 v-on 自定义函数
2.子组件进行操作 告知父组件 子组件内部设置这个自定义事件是如何触发 $emit

过程 当子组件的按钮被点击时 ==> 触发 $emit('短横线链接起来的事件名') ==> 间接触发了 短横线链接起来的事件名 自定义事件 ==> 然后触发父组件调用子组件时设置的 v-on:短横线链接起来的事件名 === 最终触发了相应的函数

解释：要注意$emit只是用来触发一个自定义的事件，这个事件对应外部父组件调用子组件时，对子组件添加的v-on所监听的事件，$emit并不能触发任何函数操作，仅仅如同一个触发器。

## 子组件传递数据给父组件（添加第二个参数）
两种方式 
* 一种是直接在子组件后 @click="$emit('send-msg',参数)"
* 另外是写一个事件名 this.$emit(事件名称, 参数) 这个是用来触发事件的！